---------Smarandoiu Cristian Andrei 322CC---------

Descriere functii:
Main - 0x080489A9 
SwitchCases - 0x0804893A - 0 parametrii - citeste optiunea user-ului si deschide functia
                                          implicita corespunzatoare index-ului
SerialKey - 0x08048679 - 0 parametrii - verifica daca seril-key-ul introdus este valid
checkKey - 0x08048A5D - 1 parametru - functia folosita la SerialKey
Username - 0x080486EA - 0 parametrii - citeste username-ul
Address - 0x08048710 - 0 parametrii - citeste adresa
Functia3 - 0x08048736 - 0 parametrii, 1 variabila ( buf ) - citeste de la tastatura,
                                                            utilizat pentru exploit
Functia4 - 0x0804874E - 0 parametrii, 2 variabile ( buf, var ) - citeste de la tastatura,
                                                                 reprezinta un puzzle
Functia5 - 0x08048985 - 0 parametrii - afiseaza mesajuk "Bye!"
checkFirstName - 0x080487C0 - 0 parametrii - verifica daca string-ul contine prenumele
checkLastName - 0x080487DA - 0 parametrii - verifica daca string-ul contine numele
Vault - 0x080487F4 - 0 parametrii - apeleaza eax ( Inside Shell )
Win - 0x0804882B - 0 parametrii - verifica daca s-a realizat corect schimbarea variabilei
TryHarder - 0x08048862 - 0 param - afiseaza "Try harder"
Exploit1 - 0x08048895 - 0 param - modifica o variabila
Exploit2 - 0x080488BA - 1 parametru - verifica daca acesta este egal cu DEADCODE
Exploit3 - 0x080488EA - 2 parametrii - sistem de ecuatii, modifica variabila

Descriere Task1:

Pentru depanarea executabilului aferent am folosit utilitarul IDA. Am observat 
ca pentru gasirea unui key valid trebuie sa analizez functia aflata la adresa 
0x8048A5D, care are ca parametru o adresa pe 8 biticare pointeaza catre adresa 
de inceput a inputului dat de utilizator dupa ce a ales optiunea "0. Solve de puzzle."

Descriere functie:
    Registru eax: valoarea de adevara a functiei initializata cu 1
    Registru ebx: folosit pentru parcurgerea sirului de input.
    Registrele ecx, edx: foloste pentru prelucrarea datelor 
    Functia de la adresa 0x8048A20 (reinitiateRegisters): nu primeste parametrii, lucreaza cu registrii
aferenti. Aceasta initializeaza registrii ah, ecx, edx, esi cu 0.
    Functie de la adresa 0x8048A52 (checkRegister): primeste ca parametrii flag-urile si verifica
daca functia de comparare "cmp" a modificat un flag. In functia de zero flag, in caz
ca acesta este inactiv, eax se modifica in 0, rezultand ca serial-key-ul introdus 
nu este valid. In ambele cazuri, codul este parcurs pana la sfarsit, dar nicaieri
eax nu poate fi modificat inapoi in 1.
    Functie de la adresa 0x8048A52 (hexaToAscii): nu primeste parametrii, lucreaza cu registrii 
aferenti. Ea modifica un caracter din valoare hexa in ascii ( 0->9, a->f ).

    Pentru determinarea caracterelor introduse, am realizat ca exista blocuri de
cod sub forma a ecuatii. Voi descrie in urmatorele randuri fiecare bloc regasit:
    1. Ecuatii cu 3 necunoscute de gradul 1. Acestea sunt sub forma hexazecimala:

    a = *p + *(p+1);
    b = *p + *(p+2);
    c = *(p+1) + *(p+2);
    
    In urma realizarii sistemului, se afla cele 3 caractere aferente.

    2. Ecuatii cu xor si and:
    
    a = *p ^ *(p+1);
    b = *p & *(p+1);
    c = *(p+1);

    3. Shift left/right

    a = ( *p << 4 ) ^ F0
    b = ( *p >> 4 ) ^ 0F

    Se observa ca se aplica operatie xor de FF pe *p si se inverseaza cei doi nibble 
pentru determinarea caracterului hexa.

    4. Folosirea functiei descrise mai sus ( transformarea hexa -> Ascii ). In program
apar 2 ecuatii de forma *phex + *(p+1)hex = a si *(p+1)hex = b. Valorile rezultate in
urma functiei sunt adaugate direct la serial-key.

    Concluzie: au fost necesare 4 tipuri de blocuri de operatii pentru determinarea 
serial-key-ului aferent rezolvarii task-ului.

------------------------------------------------------------------------------
2. Vulnerabilitati

    Situatie de tip buffer-overflow: functia 3 - Broken Keycheck
Spatiul alocat pe stiva este de 4 octeti, in schimb functia _read asteapta sa citeasca
24 de octeti. Prin urmare, se va realiza buffer overflow de 20 de octeti, putandu-se 
suprascrie adresa de retur a functiei in cauza ( primii 4 octetii offset + adresa de retur ).
Nu numai atat, dar aceasta poate fi urmat de un lant de alte adrese de functii. 

    Situatie de tip buffer-overflow: functia de dupa call eax ( inside the vault )
Spatiul alocat pe stiva este de 1000 de octeti, dar dimensiunea buffer-ului este de 1024 de 
caractere urmate de null. Prin urmare, adresa de retur poate fi suprascrisa si poate duce 
la schimbari in flow control-ul prorgamului in cazul folosirii necorespunzatoare ale buff-ului.

    Situatie de ShellInjection: buffer-ul utilizat drept MagicString poate fi utilizat pentru
a creea o functie care sa indeplineasca diferite task-uri ( la 3 voi explica cum am utilizat
acest lucru pentru a modifica o varibila utila in Vault )

------------------------------------------------------------------------------
3. Exploatare

    Precum am descris si la exercitiul 2, m-am folosit de functia 3 - Broken Keycheck pentru
a altera fluxul programului. Folosind utilitarul IDA, am luat pas cu pas fiecare lucru ce trebuie
facut pentru a deschide Vault-ul.
    1. Conform grafului, aveam nevoie de modificat 3 variabile globale. Astfel, folosindu-ma de
functia 3, am suprascris adresa de retur a acesteia cu fiecare functie din cele 3 mentionate,
setand urmatorul set de 4 octeti ca adresa functiei 3, pentru ca EIP sa pointeze la ea si sa 
ruleze inca o data functia 3. Fiind insuficienti numarul de octeti, a fost nevoie de rularea repetata
a acesteia.
    Prima functie (0x08048895): nu are parametrii, doar modifica variabila
    A doua functie (0x080488BA): un parametru, modifica varibila daca acesta este egal cu DEADCODE
    A treia functie (0x080488EA): 2 parametrii, rezolva un sistem pentru a modifica variabila

    2. Urmatorul bloc necesita introducerea a 1024 de caractere, iar pentru a patrunde in Vault,
este nevoie ca acestea sa contina numele personal si suma tuturor 1024 de caractere sa fie 12345h.

    3. Gasim inca o oportunitate de exploit in call eax, care aloca pe stiva 1000 de octeti. Pe urma
modifica fiecare octet din acestia cu cei din buff, care este de dimeniune 1024. Prin urmare, putem
suprascrie adresa de retur a acesteia cu cea de care avem nevoie. MagicString-ul se modifica 
corespuznator, indicat in payload. 

4. Pana acum, aceasta solutie ne returneaza doar mesajul "Try Harder!". Prin urmare, am adaugat 
in locul caracterelor de la pozitia 20 din buffer-ul folosit anterior, o secventa de opcode-uri 
care modifica valoarea de verificare de la adresa 0x0804A368 in valoarea data de eax ( in cazul meu,
0xba208000 ). 
Aceasta a fost obtinuta ruland cu gdb si verificand valoarea registrilor.
    Forma buffer:
    PrenumeNume ( 18 caractere )
    dummy (2 caractere )
    ShellCode ( 19 caractere - aflat la [ebp - buf + 20] -> 0xbfffe944 )
    dummy ( 80 + 883 caractere )
    ShellAddress ( suprascrie valoarea de retur a functiei cu adresa primei instructiuni din SHellCode )
    VaultAddress ( Afiseaza mesajul Win, verificand corespunzator variabilele )
    SwitchAddress ( Afiseaza mesajul "Bye" )
    dummy( 8 caractere )

    IMPORTANT!
    Tema a fost realizata integral, local afisand mesajele aferente "Win" si "Bye!" din gdb utilizand 
payload-ul din arhiva.
